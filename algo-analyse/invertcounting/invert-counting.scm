;;sort-and-count:
;;		return cons of (number-of-inversion sorted-list)
(define (sort-and-count a)
    ;;merge-and-count:
    ;; 			return cons of (number-of-inversion sorted-list)
    (define (merge-and-count left right)
        (cond ((null? left) (cons 0 right))
	      ((null? right) (cons 0 left))
              ((<= (car left) (car right))
		  (let ((rt (merge-and-count (cdr left) right)))
                      (cons (+ 0 (car rt))
			    (cons (car left) (cdr rt)))))
	      (else
                  (let ((rt (merge-and-count left (cdr right))))
		     (cons (+ (length left)
                              (car rt))
			   (cons (car right) (cdr rt)))))))
    (define (left-n a n)
        (if (= n 0)
	    '()
            (cons (car a) (left-n (cdr a) (- n 1)))))
    (define (skip-n a n)
	(if (= n 0)
	    a
            (skip-n (cdr a) (- n 1))))
    (cond ((= (length a) 0) (cons 0 '()))
 	  ((= (length a) 1) (cons 0 a))
          (else
	     (let ((half (truncate (/ (length a) 2))))
		  (let ((left-rt (sort-and-count (left-n a half)))
			(right-rt (sort-and-count (skip-n a half))))
                       (let ((merge-rt (merge-and-count (cdr left-rt) (cdr right-rt))))
		           (cons (+ (car left-rt)
				    (car right-rt)
				    (car merge-rt))
				 (cdr merge-rt))))))))

(define (invert-counting a)
    (car (sort-and-count a)))
